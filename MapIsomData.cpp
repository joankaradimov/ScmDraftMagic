#include "SCMDGlobal.h"

#include "MapIsomData.h"
//	SCMDRAFT 2 - COPYRIGHT 2001-202X STORMCOAST FORTRESS
//	BLA BLA BLA


//	These tables may be hardcoded, tool generated, or generated by code that is not implemented.
#include "CIsoTables.h"




const size_t MapIsomData::IsomRect::DirectionIndices[]	= {	0x02, 0x03,
															0x00, 0x03, 
															0x00, 0x01, 
															0x01, 0x02 };


void MapIsomData::IsomRect::SetIsomValue(	__in const size_t dirIndex,
											__in const unsigned __int16 value )
{
	unsigned __int16 modifiedValue = (value << 4) | (dirIndex << 2);
	this->SetRawIsomValue(IsomRect::DirectionIndices[dirIndex * 2 + 0], modifiedValue | (0 << 1) );
	this->SetRawIsomValue(IsomRect::DirectionIndices[dirIndex * 2 + 1], modifiedValue | (1 << 1) );
}

void MapIsomData::IsomRect::SetRawIsomValue(	__in const size_t arrayIndex,
												__in const unsigned __int16 value )
{
	this->values[arrayIndex] = value;
}

unsigned __int16 MapIsomData::IsomRect::GetRawIsomValue(	__in const size_t arrayIndex ) const
{
	return this->values[arrayIndex] & ~(IsomRect::ISOM_FLAG_SKIPPED | MapIsomData::IsomRect::ISOM_FLAG_EDITED);
}


void MapIsomData::IsomRect::SetIsomValueChanged(	__in const size_t dirIndex )
{
	this->values[IsomRect::DirectionIndices[dirIndex * 2 + 0]] |= IsomRect::ISOM_FLAG_EDITED;
	this->values[IsomRect::DirectionIndices[dirIndex * 2 + 1]] |= IsomRect::ISOM_FLAG_EDITED;
}

void MapIsomData::IsomRect::SetDirVisited(	__in const size_t dirIndex )
{
	this->values[IsomRect::DirectionIndices[dirIndex * 2 + 0]] |= IsomRect::ISOM_FLAG_SKIPPED;
	this->values[IsomRect::DirectionIndices[dirIndex * 2 + 1]] |= IsomRect::ISOM_FLAG_SKIPPED;
}

void MapIsomData::IsomRect::ClearDirVisited(	__in const size_t dirIndex )
{
	this->values[IsomRect::DirectionIndices[dirIndex * 2 + 0]] &= ~IsomRect::ISOM_FLAG_SKIPPED;
	this->values[IsomRect::DirectionIndices[dirIndex * 2 + 1]] &= ~IsomRect::ISOM_FLAG_SKIPPED;
}

bool MapIsomData::IsomRect::GetDirVisited(	__in const size_t dirIndex ) const
{
	return (this->values[IsomRect::DirectionIndices[dirIndex * 2 + 0]] & IsomRect::ISOM_FLAG_SKIPPED) == IsomRect::ISOM_FLAG_SKIPPED;
}




bool MapIsomData::IsomRect::GetChanged( void ) const
{
	return this->values[0] & IsomRect::ISOM_FLAG_EDITED;
}

bool MapIsomData::IsomRect::GetEitherLRChanged( void ) const
{
	return ((this->values[0] | this->values[2]) & IsomRect::ISOM_FLAG_EDITED) == IsomRect::ISOM_FLAG_EDITED;
}

bool MapIsomData::IsomRect::GetBothLRChanged( void ) const
{
	return ((this->values[0] & this->values[2]) & IsomRect::ISOM_FLAG_EDITED) == IsomRect::ISOM_FLAG_EDITED;
}

void MapIsomData::IsomRect::ClearChanged( void )
{
	this->values[0] &= ~(IsomRect::ISOM_FLAG_EDITED | IsomRect::ISOM_FLAG_SKIPPED);
	this->values[1] &= ~(IsomRect::ISOM_FLAG_EDITED | IsomRect::ISOM_FLAG_SKIPPED);
	this->values[2] &= ~(IsomRect::ISOM_FLAG_EDITED | IsomRect::ISOM_FLAG_SKIPPED);
	this->values[3] &= ~(IsomRect::ISOM_FLAG_EDITED | IsomRect::ISOM_FLAG_SKIPPED);
}


MapIsomData::MapIsomData( void )
{
	this->width = 0;
	this->height = 0;

	this->isomDataTbl			= nullptr;
	this->isomDataTableLength	= 0;
	this->matchPathCache		= nullptr;
	this->tileToIsomTbl			= nullptr;
	this->tileToIsomTableLength	= 0;
}

MapIsomData::~MapIsomData( void )
{
	this->width = 0;
	this->height = 0;
	this->data = nullptr;
}

HRESULT MapIsomData::Create(	__in const size_t mapWidth,
								__in const size_t mapHeight )
{
	HRESULT hr;

	this->width  = MapIsomData::TileXPosToIsomXPos( mapWidth )  + 1;
	this->height = MapIsomData::TileYPosToIsomYPos( mapHeight ) + 1;

	hr = ALLOCATE_UNIQUEPTR_ARRAY( data, MapIsomData::IsomRect, this->GetWidth() * this->GetHeight() );
	RETURNHRSILENT_IF_ERROR( hr );
	::memset( this->data.get(), 0, sizeof(MapIsomData::IsomRect) * this->GetWidth() * this->GetHeight() );

	return S_OK;
}

HRESULT MapIsomData::CopyFrom(	__inout MapIsomData *isomData,
								__in const __int32 xOffsetTiles,
								__in const __int32 yOffsetTiles )
{
	HRESULT hr;
	VERIFYARG( isomData );

	const __int32 xOffset = xOffsetTiles / 2;
	const __int32 yOffset = yOffsetTiles;

	TileRect	sourceRc;
	hr = TileRect::CreateOffsettedSourceRect( isomData->GetWidth(), isomData->GetHeight(), this->GetWidth(), this->GetHeight(), xOffset, yOffset, &sourceRc );
	RETURNHRSILENT_IF_ERROR( hr );

	for (TileCoordinate y=sourceRc.top;y < sourceRc.bottom;++y)
	{
		const MapIsomData::IsomRect *srcRow = isomData->data.get() + y * isomData->GetWidth() + sourceRc.left;
		MapIsomData::IsomRect *destRow = this->data.get() + (y + yOffset) * this->GetWidth() + sourceRc.left + xOffset;
		::memcpy( destRow, srcRow, sizeof(MapIsomData::IsomRect) * (sourceRc.right - sourceRc.left) );
	}

	return S_OK;
}


HRESULT MapIsomData::InitializeToValue(	__in const unsigned __int16 value )
{
	for (size_t i=0;i<this->GetWidth() * this->GetHeight(); ++i)
	{
		this->data[i].SetRawIsomValue(0, value);
		this->data[i].SetRawIsomValue(1, value);
		this->data[i].SetRawIsomValue(2, value);
		this->data[i].SetRawIsomValue(3, value);
	}

	return S_OK;
}

HRESULT MapIsomData::Load(	__in const size_t length,
							__in const unsigned __int16 *srcData )
{
	if (length != this->GetWidth() * this->GetHeight() * 4)
		return E_INVALIDARG;
	if (length == 0)
		return S_OK;
	VERIFYARG( srcData );

	//	Without endian fixes, all of this collapses to a memcpy
	for (size_t i=0;i<this->GetWidth() * this->GetHeight(); ++i)
	{
		this->data[i].SetRawIsomValue(0, FixEndianWORD( srcData[i * 4 + 0] ) );
		this->data[i].SetRawIsomValue(1, FixEndianWORD( srcData[i * 4 + 1] ) );
		this->data[i].SetRawIsomValue(2, FixEndianWORD( srcData[i * 4 + 2] ) );
		this->data[i].SetRawIsomValue(3, FixEndianWORD( srcData[i * 4 + 3] ) );
	}

	return S_OK;
}

HRESULT MapIsomData::Save(	__in const size_t length,
							__inout unsigned __int16 *destData ) const
{
	if (length != this->GetWidth() * this->GetHeight() * 4)
		return E_INVALIDARG;
	if (length == 0)
		return S_OK;
	VERIFYARG( destData );

	//	Without endian fixes, all of this collapses to a memcpy
	for (size_t i=0;i<this->GetWidth() * this->GetHeight(); ++i)
	{
		destData[i * 4 + 0] = FixEndianWORD( this->data[i].GetRawIsomValue(0) );
		destData[i * 4 + 1] = FixEndianWORD( this->data[i].GetRawIsomValue(1) );
		destData[i * 4 + 2] = FixEndianWORD( this->data[i].GetRawIsomValue(2) );
		destData[i * 4 + 3] = FixEndianWORD( this->data[i].GetRawIsomValue(3) );
	}

	return S_OK;
}



HRESULT MapIsomData::SetTilesetType(	__in const SCEngine::TilesetIndex tilesetID )
{
	HRESULT hr;

	this->isomDataTbl			= TileSetIsomMatchingData[tilesetID][0];
	this->isomDataTableLength	= (size_t)(TileSetIsomMatchingData[tilesetID][3]);
	this->tileToIsomTbl			= TileSetIsomMatchingData[tilesetID][2];
	this->tileToIsomTableLength	= (size_t)(TileSetIsomMatchingData[tilesetID][4]);

	std::unique_ptr<IsomGroup[]> newMatchPathCache;
	hr = this->GenerateMatchPathTable(	TileSetIsomMatchingData[tilesetID][1],
										(size_t)(TileSetIsomMatchingData[tilesetID][4]),
										&newMatchPathCache );
	RETURNHRSILENT_IF_ERROR( hr );

	this->matchPathCache = std::move( newMatchPathCache );
//	this->matchPathCacheSize = tileToIsomTableLength * tileToIsomTableLength;

	return S_OK;
}


unsigned __int16 MapIsomData::GetIsomVal( __in const SCEngine::TileGroupID tileGroupID )
{
	if (tileGroupID >= tileToIsomTableLength)
		return 0;

	return this->tileToIsomTbl[tileGroupID];
}

HRESULT MapIsomData::GenerateMatchPathTable(	__in const DWORD *tileConnectionTable,
												__in const size_t maxIsomValue,
												__out std::unique_ptr<IsomGroup[]> *matchPathCache )
{
	HRESULT hr;
	VERIFYPARG( matchPathCache );
	VERIFYARG( tileConnectionTable );
	if (maxIsomValue > (std::numeric_limits<IsomGroup>::max)())
		return E_INVALIDARG;

	std::unique_ptr<IsomGroup[]> tempPathTable;
	hr = ALLOCATE_UNIQUEPTR_ARRAY( tempPathTable, IsomGroup, maxIsomValue * maxIsomValue );
	::memset( tempPathTable.get(), 0, sizeof(IsomGroup) * maxIsomValue * maxIsomValue );

	std::unique_ptr<IsomGroup[]> finalPathTable;
	hr = ALLOCATE_UNIQUEPTR_ARRAY( finalPathTable, IsomGroup, maxIsomValue * maxIsomValue );
	::memset( finalPathTable.get(), 0, sizeof(IsomGroup) * maxIsomValue * maxIsomValue );

	//	The connection table has connections per tile type 0 terminated,
	//	and an empty row to signify the end of the table

	const DWORD *connectionTableSeeker = tileConnectionTable;
	while (true)
	{
		if (! connectionTableSeeker[0])
			break;

		size_t destRowIndex = *connectionTableSeeker;
		++connectionTableSeeker;

		IsomGroup *destRowData = tempPathTable.get() + destRowIndex * maxIsomValue;
		while( *connectionTableSeeker != 0)
		{
			*destRowData = *connectionTableSeeker;
			++connectionTableSeeker;
			++destRowData;
		}
		++connectionTableSeeker;
	}

	std::unique_ptr<IsomGroup[]> rowCache;
	hr = ALLOCATE_UNIQUEPTR_ARRAY( rowCache, IsomGroup, maxIsomValue );
	RETURNHRSILENT_IF_ERROR( hr );

	//	This loop takes the sets of tiles stored in the temp table in rows,
	//	and expands them to touch all the columns they reference
	for (size_t i = maxIsomValue; i != 0; --i)
	{
		size_t curTile = i - 1;

		//	The rowcache stores an expanded version of the transition ... maybe?
		::memset( rowCache.get(), 0, sizeof(IsomGroup) * maxIsomValue );

		std::vector<IsomGroup>	crossTableStack;
		crossTableStack.push_back( curTile );
		finalPathTable[maxIsomValue*curTile+crossTableStack[0]] = curTile;

		while (! crossTableStack.empty())
		{
			IsomGroup curDestRow = crossTableStack.front(); crossTableStack.erase( crossTableStack.begin() );

			const IsomGroup* tempPathTableRow = tempPathTable.get() + curDestRow * maxIsomValue;
			IsomGroup *finalPathTableRow      = finalPathTable.get() + curTile * maxIsomValue;
			while (tempPathTableRow[0] != 0)
			{
				if (finalPathTableRow[tempPathTableRow[0]] == 0x00)
				{					
					IsomGroup nextVal = rowCache[curDestRow];
					if (nextVal == 0)
						nextVal = tempPathTableRow[0];
					crossTableStack.push_back( tempPathTableRow[0] );
					finalPathTableRow[tempPathTableRow[0]] = nextVal;
					rowCache[tempPathTableRow[0]] = nextVal;
				}
				++tempPathTableRow;
			}
		}
	}
	
	*matchPathCache = std::move( finalPathTable );
	return S_OK;
}



MapIsomData::IsomRect* MapIsomData::GetIsomRect(	__in const size_t xPosition,
													__in const size_t yPosition )
{
	return &this->data[xPosition + yPosition * this->GetWidth()];
}


unsigned __int16 MapIsomData::GetIsomValue(	__in const size_t xPosition,
											__in const size_t yPosition )
{
	return this->data[xPosition + yPosition * this->GetWidth()].GetRawIsomValue( 0 ) >> 4;
}


bool MapIsomData::GetIsomValueChanged(	__in const size_t xPosition,
										__in const size_t yPosition )
{
	return this->data[xPosition + yPosition * this->GetWidth()].GetChanged();
}

void MapIsomData::SetIsomValue(	__in const size_t xPosition,
								__in const size_t yPosition,
								__in const size_t dirIndex,
								__in const unsigned __int16 value )
{
	size_t nodeIndex = xPosition + yPosition * this->GetWidth();
	this->data[nodeIndex].SetIsomValue( dirIndex, value );
}


void MapIsomData::SetIsomValueChanged(	__in const size_t xPosition,
										__in const size_t yPosition,
										__in const size_t dirIndex )
{
	size_t nodeIndex = xPosition + yPosition * this->GetWidth();
	this->data[nodeIndex].SetIsomValueChanged( dirIndex );
}

